#!/usr/bin/env python3

import argparse
import re
import os
import signal
import subprocess
import sys
import threading
from typing import IO, Set, TextIO

from pylspclient.json_rpc_endpoint import JsonRpcEndpoint
from pylspclient.lsp_endpoint import LspEndpoint
from pylspclient.lsp_client import LspClient
from pylspclient.lsp_structs import TextDocumentItem, LANGUAGE_IDENTIFIER


class ReadPipe(threading.Thread):
    def __init__(self, pipe: IO[bytes], out: TextIO):
        threading.Thread.__init__(self)
        self.pipe = pipe
        self.out = out

    def run(self):
        line = self.pipe.readline().decode("utf-8")
        while line:
            print(line, file=self.out)
            line = self.pipe.readline().decode("utf-8")


def kill_child_process(sig, _, child_processes, pbar):
    """Kill child processes on SIGINT"""
    assert sig == signal.SIGINT
    if pbar is not None:
        pbar.close()
    for child in child_processes:
        print(f"Terminating child process {child.pid}...", file=sys.stderr)
        child.terminate()
        child.wait()
        print(f"Child process {child.pid} terminated.", file=sys.stderr)
    sys.exit(1)


class FileExtensionFilter:
    def __init__(self, extensions: Set[str]):
        self.extensions = extensions

    def __call__(self, file_path):
        return os.path.splitext(file_path)[1][1:] in self.extensions


def _file_uri(path: str):
    return "file://" + path


def _uri_file(uri: str):
    if not uri.startswith("file://"):
        raise ValueError("Not a file URI: " + uri)
    return uri[7:]


class DiagnosticCollector:

    class bcolors:
        error = '\033[91m'
        warning = '\033[93m'
        info = '\033[96m'
        hint = '\033[94m'
        note = '\033[90m'
        green = '\033[92m'
        bold = '\033[1m'
        endc = '\033[0m'


    
    SEVERITY = {
        1: f"{bcolors.error}Error{bcolors.endc}",
        2: f"{bcolors.warning}Warning{bcolors.endc}",
        3: f"{bcolors.info}Information{bcolors.endc}",
        4: f"{bcolors.hint}Hint{bcolors.endc}",
    }
    SEVERITY_INT = {
        "error": 1,
        "warn": 2,
        "info": 3,
        "hint": 4,
    }
    SEVERITY_GITHUB = {
        1: "error",
        2: "warning",
        3: "notice",
        4: "notice",
    }


    def __init__(self):
        self.diagnostics = {}
        self.requested_files = set()
        self.cond = threading.Condition()

    def handle_publish_diagnostics(self, args):
        file = _uri_file(args["uri"])
        if file not in self.requested_files:
            return
        self.cond.acquire()
        self.diagnostics[file] = args["diagnostics"]
        self.cond.notify()
        self.cond.release()

    def request_diagnostics(self, lsp_client: LspClient, file_path: str):
        file_path = os.path.abspath(file_path)
        languageId = LANGUAGE_IDENTIFIER.CPP
        version = 1
        text = open(file_path, "r").read()
        self.requested_files.add(file_path)
        lsp_client.didOpen(
            TextDocumentItem(_file_uri(file_path), languageId, version, text)
        )

    def check_failed(self, fail_on_severity: str) -> bool:
        severity_level = self.SEVERITY_INT[fail_on_severity]
        for diagnostics in self.diagnostics.values():
            for diagnostic in diagnostics:
                if diagnostic["severity"] <= severity_level:
                    return True
        return False
    
    def create_code_context(self, file : str, line_start : int, col_start : int, col_end : int, amount_of_context : int) -> str:
        code = ""
        width = 5
        line_indicator = " |  "
        with open(file, 'r') as f:
            content = f.readlines()
            code = content[line_start - amount_of_context: line_start + amount_of_context + 1]
            
        highlight = f"{' ' * (col_start) + '^' + '-' * (col_end - col_start - 1)}\n"
        highlight_prefix  = f"{' ' * width}{line_indicator}"
        highlight_colored = f"{highlight_prefix}{self.bcolors.green}{highlight}{self.bcolors.endc}"
        
        for idx in range(len(code)):
            line_number = line_start - amount_of_context + idx + 1 # + 1 due to zero indexing
            code[idx] = f"{line_number :{width}}{line_indicator}" + code[idx]
            if not code[idx].endswith('\n'):
                code[idx] += '\n'

        code.insert(amount_of_context + 1, highlight_colored)
        code = "".join(code)

        return code
    
    def create_diagnostic_message(self, file : str, line_start : int, col_start : int, severity : str, message : str, check : str, context : str) -> str:

        output = [
            f"{file}:{line_start + 1}:{col_start + 1}: {severity}: {message} {check}\n",
            f"{context}",
        ]
        output = "".join(output)

        return output

    def fancy_diagnostics(self, amount_of_context : int) -> str:

        fancy_output = ""

        for file, diagnostics in sorted(self.diagnostics.items()):
            
            if len(diagnostics) == 0:
                continue

            for diagnostic in diagnostics:

                if 'code' not in diagnostic:
                    continue

                message = diagnostic["message"].replace(" (fix available)", '')

                message_list = []
                if "\n" in message:
                    message_list = message.split("\n")
                    message_list = [s.replace("\n", "") for s in message_list]
                    message = message_list[0]
                    message_list = [item for item in  message_list[1:] if item]

                raw_check = code = diagnostic.get("code", None)
                check = f"[{raw_check}]" if code else ""

                raw_severity = diagnostic.get("severity", None)
                severity = f"{self.SEVERITY[raw_severity]}" if raw_severity else ""

                line_start = diagnostic["range"]["start"]["line"]

                col_start = diagnostic["range"]["start"]["character"]
                col_end = diagnostic["range"]["end"]["character"]
                
                context = self.create_code_context(file, line_start, col_start, col_end, amount_of_context)

                fancy_output += self.create_diagnostic_message(file, line_start, col_start, severity, message, check , context)

                if message_list:
                    for extra_message in message_list:
                        match_code_loc = re.match(r'.*:(\d+):(\d+):.*', extra_message)
                        if match_code_loc:
                            line = int(match_code_loc.group(1)) - 1
                            col = int(match_code_loc.group(2)) 
                        extra_message = " ".join(extra_message.split(" ")[2:])
                        context = self.create_code_context(file, line, col, col, 0) 
                        note = f"{self.bcolors.note}Note{self.bcolors.endc}"
                        fancy_output += self.create_diagnostic_message(file, line, col, note, extra_message, "" , context)    

                fancy_output += "\n"
                    
        return fancy_output

    def workflow_commands_for_github_actions(self, git_root: str) -> str:
        commands = "::group::{workflow commands}\n"
        for file, diagnostics in sorted(self.diagnostics.items()):
            if len(diagnostics) == 0:
                continue
            for diagnostic in diagnostics:
                source = diagnostic.get("source", None)
                severity = diagnostic.get("severity", None)
                code = diagnostic.get("code", None)
                extra_info = "{}{}{}".format(
                    f"{source}" if source else "",
                    f" {self.SEVERITY[severity]}" if severity else "",
                    f" [{code}]" if code else "",
                )
                line = diagnostic["range"]["start"]["line"] + 1
                end_line = diagnostic["range"]["end"]["line"] + 1
                col = diagnostic["range"]["start"]["character"] + 1
                end_col = diagnostic["range"]["end"]["character"] + 1
                message = diagnostic["message"]
                if source is None and code is None:
                    continue
                command = self.SEVERITY_GITHUB[severity]
                rel_file = os.path.relpath(file, git_root)
                commands += f"::{command} file={rel_file},line={line},endLine={end_line},col={col},endCol={end_col},title={extra_info}::{message}\n"
        commands += "::endgroup::"
        return commands


if __name__ == "__main__":
    DEFAULT_ALLOW_EXTENSIONS = [
        "c",
        "h",
        "cpp",
        "cc",
        "cxx",
        "hpp",
        "hh",
        "hxx",
        "cu",
        "cuh",
    ]

    parser = argparse.ArgumentParser(
        prog="clangd-tidy",
        description="Run clangd with clang-tidy and output diagnostics. This aims to serve as a faster alternative to clang-tidy.",
        epilog="Find more information on https://github.com/lljbash/clangd-tidy.",
    )
    parser.add_argument(
        "-p",
        "--compile-commands-dir",
        default="build",
        help="Specify a path to look for compile_commands.json. If the path is invalid, clangd will look in the current directory and parent paths of each source file. [default: build]",
    )
    parser.add_argument(
        "-j",
        "--jobs",
        type=int,
        default=1,
        help="Number of async workers used by clangd. Background index also uses this many workers. [default: 1]",
    )
    parser.add_argument(
        "-o",
        "--output",
        type=argparse.FileType("w"),
        default=sys.stdout,
        help="Output file for diagnostics. [default: stdout]",
    )
    parser.add_argument(
        "--clangd-executable",
        default="clangd",
        help="Path to clangd executable. [default: clangd]",
    )
    parser.add_argument(
        "--allow-extensions",
        default=DEFAULT_ALLOW_EXTENSIONS,
        help=f"A comma-separated list of file extensions to allow. [default: {','.join(DEFAULT_ALLOW_EXTENSIONS)}]",
    )
    parser.add_argument(
        "--fail-on-severity",
        metavar="SEVERITY",
        choices=DiagnosticCollector.SEVERITY_INT.keys(),
        default="hint",
        help=f"On which severity of diagnostics this program should exit with a non-zero status. Candidates: {', '.join(DiagnosticCollector.SEVERITY_INT)}. [default: hint]",
    )
    parser.add_argument(
        "--tqdm", action="store_true", help="Show a progress bar (require tqdm)."
    )
    parser.add_argument(
        "--github",
        action="store_true",
        help="Append workflow commands for GitHub Actions to output.",
    )
    parser.add_argument(
        "--git-root",
        default=os.getcwd(),
        help="Root directory of the git repository. Only works with --github. [default: current directory]",
    )
    parser.add_argument(
        "-v", "--verbose", action="store_true", help="Print verbose output from clangd."
    )
    parser.add_argument(
        "-c",
        "--context",
        type=int,
        default=2,
        help="Number of lines of code shown either side of the detected issue. [default: 2]",
    )
    parser.add_argument(
        "filename",
        nargs="+",
        help="Files to check. Files whose extensions are not in ALLOW_EXTENSIONS will be ignored.",
    )
    args = parser.parse_args()

    ext_filter = FileExtensionFilter(set(map(str.strip, args.allow_extensions)))
    files = list(filter(ext_filter, args.filename))
    for file in files:
        if not os.path.isfile(file):
            print(f"File not found: {file}", file=sys.stderr)
            sys.exit(1)

    clangd_command = [
        f"{args.clangd_executable}",
        f"--compile-commands-dir={args.compile_commands_dir}",
        "--clang-tidy",
        f"-j={args.jobs}",
        "--pch-storage=memory",
        "--enable-config",
        "--offset-encoding=utf-16",
    ]

    p = subprocess.Popen(
        clangd_command,
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
    )
    assert p.stderr is not None
    read_pipe = ReadPipe(p.stderr, args.verbose and sys.stderr or open(os.devnull, "w"))
    read_pipe.start()

    # Kill clangd subprocess on SIGINT
    pbar = None  # use to close progress bar if it exists
    signal.signal(signal.SIGINT, lambda sig, _: kill_child_process(sig, _, [p], pbar))

    collector = DiagnosticCollector()

    json_rpc_endpoint = JsonRpcEndpoint(p.stdin, p.stdout)
    lsp_endpoint = LspEndpoint(
        json_rpc_endpoint,
        notify_callbacks={
            "textDocument/publishDiagnostics": lambda args: collector.handle_publish_diagnostics(
                args
            ),
        },
    )
    lsp_client = LspClient(lsp_endpoint)

    root_path = os.path.abspath(".")
    root_uri = _file_uri(root_path)
    workspace_folders = [{"name": "foo", "uri": root_uri}]

    lsp_client.initialize(p.pid, None, root_uri, None, None, "off", workspace_folders)
    lsp_client.initialized()

    for file in files:
        collector.request_diagnostics(lsp_client, file)

    if args.tqdm:
        try:
            from tqdm import tqdm
        except ImportError:
            print(
                "tqdm not found. Please install tqdm to enable progress bar.",
                file=sys.stderr,
            )
            args.tqdm = False

    if args.tqdm:
        from tqdm import tqdm

        with tqdm(total=len(files)) as pbar:
            collector.cond.acquire()
            while len(collector.diagnostics) < len(files):
                pbar.update(len(collector.diagnostics) - pbar.n)
                collector.cond.wait()
            pbar.update(len(collector.diagnostics) - pbar.n)
            collector.cond.release()
    else:
        collector.cond.acquire()
        while len(collector.diagnostics) < len(files):
            collector.cond.wait()
        collector.cond.release()

    lsp_client.shutdown()
    lsp_client.exit()
    lsp_endpoint.join()
    os.wait()
    if read_pipe.is_alive():
        read_pipe.join()

    diagnostics = collector.fancy_diagnostics(args.context).strip()
    print(diagnostics, file=args.output)
    if args.github:
        print(
            collector.workflow_commands_for_github_actions(args.git_root).strip(),
            file=args.output,
        )
    if collector.check_failed(args.fail_on_severity):
        exit(1)
